# 启动调试
当需要调试一个程序时，在使用gcc编译该程序时，需要添加 **-g选项，表示debug方式编译，-Wall选项，表示打印一些警告信息，-On选项表示编译器优化级别**。
```
-O0: 禁用所有优化，便于调试。这是调试时的默认优化级别。
-O1、-O2、-O3：启用不同级别的优化。优化级别越高，生成的代码性能越好，但调试信息可能会受到一定影响。
```
## 1.启动调试并传入参数
启动gdb时
```
gdb --args xxx < args >
```
启动gdb后 run程序之前
```
set args < args >
r < args >
```
## 2.附加到已经启动的程序
一旦附加成功，被附加的程序会立刻暂停（所有线程都会暂停），然后可以设置断点，然后continue继续运行触发断点
```
gdb attach < pid >
gdb --pid < pid >
```
## 3.逐过程执行
```
next     (遇到不进入函数一步步执行,直接跳转到下一条代码处)
n

gdb中 可以不传入命令直接回车 自动执行上一条命令
```
## 4.逐语句执行
```
step     (遇到函数会停留在函数第一行代码,进入函数体一步步执行)
s
```
## 5.退出当前函数
```
finish    (直接跳转到调用方的下一行代码)
```
## 6.退出调试
```
detach (通过attach附加到已经启动程序)
q (gdb自己启动的程序)
```
## 7.继续执行
```
c continue 继续执行直到遇到下一个断点则停止执行(整个程序的所有线程都继续执行)
```

# 断点管理
## 1.设置断点(程序走到断点处停住,断点行代码不执行)
当程序触发断点时，GDB会自动切换到触发断点的线程，并且所有线程都会暂停，直到使用c命令重新执行程序所有线程才会重新运行，并且使用s命令逐步执行，默认只会使当前线程执行。（如果程序正在执行一些阻塞函数，如epoll_wait，此时调用s命令，阻塞接口会被EINTR信号中断返回）
```
b (文件名):行号     在源代码文件的第n行设置断点
b 函数名            为函数设置断点 同名函数都设置
b 文件名:函数名      在指定文件的函数第一行设置断点
rb 正则表达式       将满足正则表达式的函数名函数设置断点
b 断点 条件      例如: b main.cpp:20 if i==20    设置条件断点 (只有条件满足时触发断点,通常在循环中某个特点条件满足时启动断点) 
tb 断点     临时断点 只触发一次
//程序任意一个线程触发断点，整个程序(所有线程)都暂停执行
```
## 2.查看/禁用/删除断点
```
info b 查看所有断点
disable/enable 断点编号num  启用/禁用断点
delete (断点编号num)    删除所有或者指定断点
```

# 查看/修改变量
## 1.查看变量
```
info args 查看当前函数参数
info locals 查看当前函数当前执行位置之前的所有局部变量
p [变量名]   查看变量的值
p [*指针]    查看指针指向变量的值
例如：
(gdb) print app
$4 = {_argc = 3, _argv = 0x7fffffffe1a8, _servers = std::unordered_map with 0 elements, _mainIOManager 
= std::shared_ptr<Xten::IOManager> (empty) = {get() = 0x0}}
$n：表示 GDB 的历史值编号，方便你在后续命令中引用之前打印的值。

set print null-stop 设置字符串显示规则("abcdef" 后面的\00000不显示)
set print pretty   显示结构体美观
set print array on 显示数组美观

//gdb内嵌函数
p sizeof(变量)   查看变量大小
p strlen(字符串)  查看字符串长度
``` 
## 2.修改变量(普通变量/结构体/类等)
```
print 变量=值

//基本类型  int a=10 
print a=20
//结构体对象  struct st{ int a=1;int b=2}
print st.b=3
//类对象   class ca{private: _a=1;_b=2}
print ca._b=4
```

# 查看/修改内存
## 1.查看内存
```
x /[n][format] [address]
n:表示读取内存的大小 Byte
format:显示的格式    x-十六进制  d-十进制  c-字符  s-字符串
address:查看内存的起始地址

例如:
(gdb) x /s app._argv[0]
0x7fffffffe44b:	"/home/xxxten/Xten_fiber_netlib/Xten/bin/main"
```
## 2.修改内存
```
set <address> = <value>
<address>：表示要修改的内存地址
<value>：表示要设置的新值
```

# 查看/修改寄存器
当程序发布后，不带有调试信息时，调试该程序时，使用info args或者p [变量名] 时，往往找不到对应的变量名，因此此时只能使用查看寄存器的方式，主要的作用是用来查看函数的参数传入是否正确，或者修改程序执行代码位置。
```
info registers   查看通用寄存器的值
info registers  [name]  查看指定寄存器的值

set $[寄存器名]=[新值]   修改寄存器的值
比如修改pc/rip寄存器的值，用来更改程序执行的下一条指令的地址
info line [行号]  查看指定行代码的起始地址（不止一句汇编代码）
```

# 源代码查看/管理
## 1.查看源代码
```
l list 查看源代码 默认显示10行 默认是当前文件
set listsize xxx 设置每次显示的行数

list test_func 查看指定函数代码(可指定类的函数，文件的函数)
例如：list ClassA::func      list ClassB::func      list main.cpp:main

list 文件名:行数    查看指定文件指定行的代码
```
## 2.源代码搜索路径
```
show directories   查看gdb当前搜索源文件的路径

(gdb) show directories 
Source directories searched: $cdir:$cwd
其中：
$cdir：编译目录是编译时记录的目录路径。当你使用 -g 选项编译程序时，编译器会将当前工作目录记录到可执行文件中。GDB 会尝试在这个目录中查找源文件。
$cwd：当前工作目录是 GDB 启动时的目录，或者通过 cd 命令更改后的目录。如果 GDB 在 $cdir 中找不到源文件，它会尝试在 $cwd 中查找。

directory [newpath]  添加新的源文件搜索路径  
```

# 函数调用栈管理
每一个函数都对应一个**函数栈帧**，**每一个线程都有自己的函数调用链，这个调用链就是该线程的调用栈**
```
bt backtrace 查看当前线程的函数调用栈
例如：
(gdb) bt
#0  0x00000000004d0f0b in Xten::singleton<Xten::Env>::GetInstance () at /home/xxxten/Xten_fiber_netlib/Xten/src/system/../singleton.hpp:13
#1  Xten::Application::Run (this=this@entry=0x7fffffffe000) at /home/xxxten/Xten_fiber_netlib/Xten/src/system/application.cpp:87
#2  0x00000000004ccb8c in main (argc=2, argv=0x7fffffffe188) at /home/xxxten/Xten_fiber_netlib/Xten/src/system/main.cpp:13

#0表示是最顶层的调用的函数，每一层函数后面的文件名:行号 表示是从这个文件的这个行号代码处向上层调用函数 最上层函数正处于该行号处


frame n 切换栈帧  [n就是bt显示的#n的值]
(注意：并不是真正切换调用栈,因为使用s仍然是从最顶层栈下一行代码执行，只是切换栈帧用来查看不同栈上的一些参数值而已)

info frame n 查看第n层栈帧的信息
(gdb) info frame 3
Stack frame at 0x7fffffffe080:
 rip = 0x4ccb8c in main (/home/xxxten/Xten_fiber_netlib/Xten/src/system/main.cpp:13); saved rip = 0x7ffff74342a0
 caller of frame at 0x7fffffffe000
 source language c++.
 Arglist at 0x7fffffffdff8, args: argc=2, argv=0x7fffffffe188
 Locals at 0x7fffffffdff8, Previous frame's sp is 0x7fffffffe080
 Saved registers:
  rbx at 0x7fffffffe060, rbp at 0x7fffffffe068, r12 at 0x7fffffffe070, rip at 0x7fffffffe078

```


