# 观察点
观察点的主要作用是监控程序中某个变量的值是否发生变化。当变量的值发生变化时，GDB会暂停程序的执行，让你可以检查程序的状态。这对于调试程序中的数据问题非常有用，例如：

检查变量是否被意外修改。
跟踪变量的值变化，找出问题的根源。
```
watch x  写观察点 数据被修改时会暂停程序
rwatch x 读观察点 数据被读取时暂停程序
awatch x 访问观测点 数据被读取或者修改时暂停程序

info watch 查看观察点

delete/disable/enable 删除/禁用/启动观察点
```
# 捕获点
捕获点（Catchpoint）是一种特殊的断点，用于捕获程序运行中的特定事件。捕获点可以帮助你监控程序中的异常、信号、系统调用等事件，而不仅仅是代码的执行位置。

捕获点的主要作用是捕获程序运行中的特定事件，例如：

程序抛出异常（如C++中的throw）。
程序接收到特定的信号（如SIGSEGV）。
程序执行特定的系统调用（如open、write等）。
通过设置捕获点，你可以在这些事件发生时暂停程序的执行，从而检查程序的状态，找出问题的根源。
```
catch throw 捕获程序抛出异常时暂停程序
catch catch 程序捕获异常时暂停程序
catch signal [信号编号]  当程序收到特点信号时暂停程序
catch syscall [系统调用]  程序执行特定系统调用时暂停程序
catch load
catch fork
cacth unload ........

当捕获点触发时，一般的处理逻辑就是先bt查看栈帧 再查看当前栈帧的值，或者使用frame n切换到上层栈帧查看值，找到异常的值
```
# 为断点执行命令
## 1.为断点执行命令
```
//基本用法（一旦设置命令后,之后触发该断点会自动执行设置的命令）
commands n   //n表示断点编号
cmd1
cmd2
......
end

//设置一个断点
(gdb) catch load
Catchpoint 1 (load)

//查看该断点
(gdb) info b
Num     Type           Disp Enb Address    What
1       catchpoint     keep y              load of library

//为断点执行命令
(gdb) commands 1
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
>bt
>info args
>end

//再次查看 
(gdb) info b
Num     Type           Disp Enb Address    What
1       catchpoint     keep y              load of library
        bt
        info args
```
## 2.保存断点信息到文件
```
//基本用法
save breakpoints [filename] 


(gdb) save breakpoints a.txt
Saved to file 'a.txt'.

(gdb) !ls    //在当前路径下会生成一个普通文本文件存放断点信息
a.txt  conf  main  module

(gdb) !cat a.txt  //查看该文本文件
catch load
  commands
    bt
    info args
  end

```
## 3.从文件读取断点信息
```
//基本用法
source [filename]


(gdb) delete
Delete all breakpoints? (y or n) y

(gdb) info b
No breakpoints or watchpoints.

(gdb) source a.txt 
Catchpoint 2 (load)

(gdb) info b
Num     Type           Disp Enb Address    What
2       catchpoint     keep y              load of library
        bt
        info args

```
# GDB多窗口管理
最主要是能够清楚的了解**当前代码执行位置与上下文环境，断点信息等**。

断点信息：

B+ 断点可用且命中过

b+ 断点可以未命中过

b- 断点不可用未命中过
```
layout src：显示源码窗口。
layout asm：显示汇编窗口。
layout reg：显示寄存器窗口。

layout split：切分窗口，显示源码、汇编和命令窗口。

focus src/asm/reg：切换窗口焦点。（主要是影响上下左右移动的目标窗口）
info win：查看当前拥有焦点的窗口。

Ctrl + X + A：切换多窗口模式和单窗口模式
```
# 查看对象类型
```
whatis  直接查看对象类型，但没啥用一般看源码就知道

ptype   ptype 命令用于显示变量或表达式的类型信息，与whatis类似，但ptype会提供更详细的信息，包括类的成员和方法。
(gdb) ptype app
type = class Xten::Application {
  private:
    int _argc;
    char **_argv;
    std::unordered_map<std::string, std::vector<std::shared_ptr<Xten::TcpServer>>> _servers;
    Xten::IOManager::prt _mainIOManager;

  public:
    Application(void);
    static Xten::Application * GetInstance(void);
    bool Init(int, char **);
    int Run(void);
    bool GetServersByType(const std::string &, std::vector<std::shared_ptr<Xten::TcpServer>> &);
    void GetAllServers(std::unordered_map<std::string, std::vector<std::shared_ptr<Xten::TcpServer>>> &);
  private:
    int main(int, char **);
    void run_fiber(void);
}

info variables [变量名]  一般是用来展示出符合条件的所有 全局变量或者静态全局变量

set print object on
它可以帮助你更详细地查看对象的内容，特别是当对象是多态类型时。这个命令会启用对象的动态类型打印，即在打印对象时，GDB会尝试使用对象的实际类型（动态类型）而不是声明类型（静态类型）来显示对象的内容。

```
# 多线程调试
```
info threads    查看所有线程信息
(gdb) info threads
  Id   Target Id                                      Frame 
* 1    Thread 0x7ffff7ea4ec0 (LWP 2848993) "main"     Xten::Config::LoadFromConFDir (path="/home/xxxten/Xten_fiber_netlib/Xten/bin/./conf", force=false)
    at /home/xxxten/Xten_fiber_netlib/Xten/src/config.cpp:94
  2    Thread 0x7ffff740b6c0 (LWP 2849230) "accept_0" 0x00007ffff7522f96 in epoll_wait () from /lib64/libc.so.6
  3    Thread 0x7ffff6c0a6c0 (LWP 2849231) "io_0"     Xten::http::HttpRequest::HttpRequest (this=this@entry=0x7fffe8001ac0, version=version@entry=17 '\021', close=close@entry=true)
    at /home/xxxten/Xten_fiber_netlib/Xten/src/http/http.cpp:68
  4    Thread 0x7ffff64096c0 (LWP 2849232) "io_1"     0x00007ffff7522f96 in epoll_wait () from /lib64/libc.so.6
  5    Thread 0x7ffff5c086c0 (LWP 2849233) ""         0x00007ffff74e56c5 in clock_nanosleep@GLIBC_2.2.5 () from /lib64/libc.so.6
//其中，*表示当前环境的线程

thread [num]    切换到指定num的线程 (主要是查看其他线程的值，且s/n是当前线程向下执行)

thread find [条件]   查找线程   （可以通过线程地址，线程LWP，线程名字来查找）

thread name [xxxxx]  为当前所在的线程设置名字

b breakpoint [thread id]  为指定线程设置断点  
// 只有该指定的线程触发这个断点，才会使得整个程序暂停
```
## 为线程执行命令
对多个线程应用同一个命令。这在调试多线程程序时非常有用，尤其是当你需要对所有线程执行相同的调试操作时。thread apply命令可以节省时间并提高调试效率。（比如多线程情况下需要调试死锁问题，thread apply all bt 一次查看所有线程的调用栈。如果没有这个命令，可能需要 thread n + bt 手动打印所有线程的调用栈）
```
thread apply [thread-id] [command]    
//thread-id的传入：1/2/3....（指定线程）   1-3/m-n（范围） all（所有线程）
//command的传入： 需要执行的命令，bt ，info args，info locals......  
```
# 执行外部命令
在gdb环境下，与在shell命令行上一样执行一些shell指令
```
![shell] CMD      执行shell指令

(gdb) !ls
a.txt  conf  main  module

(gdb) shell cat a.txt 
catch load
  commands
    bt
    info args
  end
```