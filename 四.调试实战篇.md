# 内存泄漏检查
## 1.gdb函数检查
对于一个程序可能的内存泄漏问题，可以使用valgrand用来检测，但是缺点是会产生错报，降低程序运行的效率并且较为复杂。也可以使用gdb的一些内置函数来初步检查内存泄漏。
```
call (void) malloc_stats()    glibc库提供的查看动态分配内存的函数

(gdb) call (void) malloc_stats()
Arena 0:
system bytes     =     405504
in use bytes     =     285760
Arena 1:
system bytes     =     135168
in use bytes     =       3136
Arena 2:
system bytes     =     135168
in use bytes     =       6368
Arena 3:
system bytes     =     135168
in use bytes     =       6368
Arena 4:
system bytes     =     135168
in use bytes     =       7680
Total (incl. mmap):
system bytes     =     946176
in use bytes     =     309312
max mmap regions =          0
max mmap bytes   =          0
//每一个线程都有属于自己的Arena区域，降低线程间空间分配的竞态条件

这个函数可以用来看某个函数的调用是否产生了内存泄漏
call (void) malloc_stats()
[调用用户可能内存泄漏的函数]
call (void) malloc_stats()
看两次的输出内存的使用量是否发生改变来确定函数内部是否发生了内存泄漏
```

## 2.使用gcc的编译选项
**gcc 的-fsanitize=address选项**
```
AddressSanitizer 是一个快速的内存错误检测器，它可以检测多种常见的内存错误，如堆栈缓冲区溢出、堆缓冲区溢出、使用后释放（use-after-free）、内存泄漏等。
```

# 多线程死锁调试思路
## 1.死锁的条件
1. 互斥
2. 保持与请求
3. 不可剥夺
4. 循环等待
## 2.解决死锁的方案
1. 顺序加锁（std::scoped_lock等）
2. 控制锁的作用范围
3. 使用超时机制
### 3.死锁调试思路
```
1.首先肯定是调用 info theads 查看所有线程的信息，看执行到了哪个函数处。根据这些信息基本可以确定那些线程是加锁阻塞住了。
2.确定了哪些线程死锁，调用 thread apply [死锁线程] bt  ，查看死锁线程的调用栈。
3.thread n切换到某个死锁线程，bt先查看调用栈，然后frame n切换到用户加锁逻辑函数。
3.然后在这个栈帧上查看变量值确定死锁原因，比如：p mutex 可以看到这个锁的持有者信息（这是非常重要的）。 
```

# coredump文件分析
一般称之为核心转储、内核转储，我们统称为转储文件。**是某个时刻某个进程的内存信息映射，即包含了生成转储文件时该进程的整个内存信息以及寄存器等信息**。转储文件可以是某个进程的，也可以是整个系统的。可以是进程活着的时候生成的，也可以是进程或者系统崩溃的时候自动生成的。**它包含了程序崩溃时的内存映像、寄存器状态、栈信息等。。这些文件对于调试程序错误非常关键，可以帮助开发人员快速定位问题。**
# 1.生成核心转储文件
```
ulimit -c ulimited     设置核心转储文件大小无限制

可以通过修改 /proc/sys/kernel/core_pattern 文件来指定 coredump 文件的存放位置和命名格式。
例如：
echo "/var/coredumps/core.%e.%p" > /proc/sys/kernel/core_pattern

1.进程存活时输出
gdb attach pid
gcore [fileName]  创建核心转储文件

2.进程崩溃时，若允许生成则自动生成核心转储文件
```
# 2.GDB调试核心转储文件
```
gdb [可执行程序文件] [coredump文件]      

后面的操作就和普通情况下调试一样，bt ,info val.....
```
# 3.例如调试栈溢出核心转储文件
```
alloca函数是 C 语言中的一个非标准扩展函数，用于在栈上动态分配内存，alloca 分配的内存会在当前函数作用域结束时自动释放。
并且alloca函数内存开辟的效率是要高于malloc函数的内存开辟效率的。（只需要移动栈指针即可）

void* alloca(size_t size);

当在一个函数中循环不断调用alloca函数的时候就会触发栈溢出错误。（linux下栈空间最大8MB） 
使用： ulimit -a 命令查看栈空间大小
```
# 4.无调试信息的coredump文件调试
**需要使用到第一章节学习的查看/修改寄存器的值的内容来调试**

